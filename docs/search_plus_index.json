{"./":{"url":"./","title":"Introduction","keywords":"","body":"dzfdzfd "},"BFS/":{"url":"BFS/","title":"BFS","keywords":"","body":"BFS "},"BFS/Shortest Path/":{"url":"BFS/Shortest Path/","title":"Shortest Path","keywords":"","body":"Dijkstra Overview Target: The shortest paths from one node to all others in the graph. Assumption: The cost of each edge cannot be negative Note: For one node, it can be pushed into queue multiple times (ie. The same node with different costs can exists in queue) As such, dedup should be at the time of pop From the whole graph point of view, all nodes popped out in increasing order. (ie. could be used to sort in some format) Template Time Complexity: O(NlgN) Space Complexity: O(N) Version 1 HashSet /** * times[i]: {u, v, cost} * N: The total # of nodes * K: Source node */ public int minDistFromKToAll(int[][] times, int N, int K) { // construct graph // key: u, value: Pair (v, cost) Map> graph = constructGraph(times, N); // init minHeap & visited nodes set Queue minHeap = new PriorityQueue<>((p1, p2) -> { return p1.cost - p2.cost; }); minHeap.offer(new Pair(K, 0)); Set visited = new HashSet<>(); // visit every node in the graph // every time a node is popped up, the cost (from source to this node) is // the shortest path for this node int maxTime = 0; while (!minHeap.isEmpty()) { Pair cur = minHeap.poll(); // we might add a node multiple times // only the first time counts if (!visited.add(cur.id)) continue; maxTime = cur.cost; for (Pair next : graph.get(cur.id)) { // visited.contains(next.id) means // the shortest dist from K to next is calculated if (visited.contains(next.id)) continue; minHeap.offer(new Pair(next.id, cur.cost + next.cost)); } } return visited.size() == N ? maxTime : -1; } Version 2 Dist array public int minDistFromKToAll(int[][] times, int N, int K) { // construct graph // key: u, value: Pair (v, cost) Map> graph = constructGraph(times, N); // init minHeap & visited nodes set Queue minHeap = new PriorityQueue<>((p1, p2) -> { return p1.cost - p2.cost; }); minHeap.offer(new Pair(K, 0)); int[] dist = new int[N + 1]; Arrays.fill(dist, Integer.MAX_VALUE); // visit every node in the graph // every time a node is popped up, the cost (from source to this node) is // the shortest path for this node int maxTime = 0; while (!minHeap.isEmpty()) { Pair cur = minHeap.poll(); // the dist has been updated if (dist[cur.id] != Integer.MAX_VALUE) continue; dist[cur.id] = cur.cost; maxTime = cur.cost; for (Pair next : graph.get(cur.id)) { if (dist[next.id] != Integer.MAX_VALUE) continue; minHeap.offer(new Pair(next.id, cur.cost + next.cost)); } } return Arrays.stream(dist) .filter(d -> d == Integer.MAX_VALUE) .count() == 1 ? maxTime : -1; } "},"BFS/Shortest Path/1293. Shortest Path in a Grid with Obstacles Elimination.html":{"url":"BFS/Shortest Path/1293. Shortest Path in a Grid with Obstacles Elimination.html","title":"1293. Shortest Path in a Grid with Obstacles Elimination","keywords":"","body":"1293. Shortest Path in a Grid with Obstacles Elimination Thoughts Method 1: Standard Dijkstra + 3-dimension as visited Method 2: Standard Queue + 3-dimension as visited Method 3: Level Order + 3-dimension as visited Code Version 1 Dijkstra class Solution { public int shortestPath(int[][] grid, int k) { int m = grid.length; if (m == 0) return 0; int n = grid[0].length; if (n == 0) return 0; if (grid[0][0] == 1 && k == 0) return -1; int[] dx = new int[]{1,-1,0,0}; int[] dy = new int[]{0,0,1,-1}; Queue minHeap = new PriorityQueue<>((s1, s2) -> { int disDiff = s1.dist - s2.dist; if (disDiff == 0) { return s2.k - s1.k; } return disDiff; }); minHeap.offer(new State(0,0,0,k - grid[0][0])); boolean[][][] visited = new boolean[m][n][k + 1]; while (!minHeap.isEmpty()) { State cur = minHeap.poll(); int x = cur.x, y = cur.y, dist = cur.dist, remainK = cur.k; if (x == m - 1 && y == n - 1) return dist; if (visited[x][y][remainK]) continue; visited[x][y][remainK] = true; for (int i = 0; i = m || ny >= n) continue; if (grid[nx][ny] == 1 && remainK == 0) continue; if (visited[nx][ny][remainK - grid[nx][ny]]) continue; minHeap.offer(new State(nx, ny, dist + 1, remainK - grid[nx][ny])); } } return -1; } private static class State { int x, y; int dist; int k; public State(int x, int y, int d, int k) { this.x = x; this.y = y; this.dist = d; this.k = k; } } } Version 2 Standard Queue Queue queue = new LinkedList<>(); Version 3 Level Order (dont need to record step) int step = 0; while (!queue.isEmpty()) { int size = queue.isEmpty(); for (int i = 0; i = m || ny >= n) continue; if (grid[nx][ny] == 1 && remainK == 0) continue; if (visited[nx][ny][remainK - grid[nx][ny]]) continue; queue.offer(new State(nx, ny, remainK - grid[nx][ny])); } } } "},"BFS/Shortest Path/1368. Minimum Cost to Make at Least One Valid Path in a Grid.html":{"url":"BFS/Shortest Path/1368. Minimum Cost to Make at Least One Valid Path in a Grid.html","title":"1368. Minimum Cost to Make at Least One Valid Path in a Grid","keywords":"","body":"1368. Minimum Cost to Make at Least One Valid Path in a Grid Thoughts Standard Dijkstra Code class Solution { public int minCost(int[][] grid) { int m = grid.length; if (m == 0) return 0; int n = grid[0].length; if (n == 0) return 0; int[] dx = new int[]{0,0,0,1,-1}; int[] dy = new int[]{0,1,-1,0,0}; Queue q = new PriorityQueue((s1, s2) -> { return s1.cost - s2.cost; }); q.offer(new State(0,0,0)); boolean[][] visited = new boolean[m][n]; while (!q.isEmpty()) { State cur = q.poll(); if (visited[cur.x][cur.y]) continue; visited[cur.x][cur.y] = true; if (cur.x == m - 1 && cur.y == n - 1) return cur.cost; for (int k = 1; k = m || ny >= n) continue; if (visited[nx][ny]) continue; int cost = grid[cur.x][cur.y] == k ? 0 : 1; q.offer(new State(nx, ny, cost + cur.cost)); } } return -1; } private static class State { int x, y; int cost; public State (int x, int y, int cost) { this.x = x; this.y = y; this.cost = cost; } } } "},"BFS/Shortest Path/743. Network Delay Time.html":{"url":"BFS/Shortest Path/743. Network Delay Time.html","title":"743. Network Delay Time","keywords":"","body":"743. Network Delay Time Thoughts Standard Dijkstra Code Version 1 HashSet class Solution { public int networkDelayTime(int[][] times, int N, int K) { // construct graph // key: u, value: Pair (v, cost) Map> graph = constructGraph(times, N); // init minHeap & visited nodes set Queue minHeap = new PriorityQueue<>((p1, p2) -> { return p1.cost - p2.cost; }); minHeap.offer(new Pair(K, 0)); Set visited = new HashSet<>(); // visit every node in the graph // every time a node is popped up, the cost (from source to this node) is // the shortest path for this node int maxTime = 0; while (!minHeap.isEmpty()) { Pair cur = minHeap.poll(); if (!visited.add(cur.id)) continue; maxTime = cur.cost; for (Pair next : graph.get(cur.id)) { if (visited.contains(next.id)) continue; minHeap.offer(new Pair(next.id, cur.cost + next.cost)); } } return visited.size() == N ? maxTime : -1; } private Map> constructGraph(int[][] times, int N) { Map> graph = new HashMap<>(); for (int i = 1; i ()); } for (int[] t : times) { graph.get(t[0]).add(new Pair(t[1], t[2])); } return graph; } private static class Pair { int id; int cost; public Pair (int id, int cost) { this.id = id; this.cost = cost; } } } Version 2 dist array public int networkDelayTime(int[][] times, int N, int K) { // construct graph // key: u, value: Pair (v, cost) Map> graph = constructGraph(times, N); // init minHeap & visited nodes set Queue minHeap = new PriorityQueue<>((p1, p2) -> { return p1.cost - p2.cost; }); minHeap.offer(new Pair(K, 0)); int[] dist = new int[N + 1]; Arrays.fill(dist, Integer.MAX_VALUE); // visit every node in the graph // every time a node is popped up, the cost (from source to this node) is // the shortest path for this node int maxTime = 0; while (!minHeap.isEmpty()) { Pair cur = minHeap.poll(); // the dist has been updated if (dist[cur.id] != Integer.MAX_VALUE) continue; dist[cur.id] = cur.cost; maxTime = cur.cost; for (Pair next : graph.get(cur.id)) { // visited.contains(next.id) means // the shortest dist from K to next is calculated if (dist[next.id] != Integer.MAX_VALUE) continue; minHeap.offer(new Pair(next.id, cur.cost + next.cost)); } } return Arrays.stream(dist) .filter(d -> d == Integer.MAX_VALUE) .count() == 1 ? maxTime : -1; } "},"DFS/":{"url":"DFS/","title":"DFS","keywords":"","body":"dzfdzfd "},"DFS/Shortest Path/":{"url":"DFS/Shortest Path/","title":"Shortest Path","keywords":"","body":"Shortest Path "},"DFS/Shortest Path/dfsd.html":{"url":"DFS/Shortest Path/dfsd.html","title":"dfsd","keywords":"","body":"dfsd "},"Heap/":{"url":"Heap/","title":"Heap","keywords":"","body":"dzfdzfd "},"Heap/Impl/":{"url":"Heap/Impl/","title":"Impl","keywords":"","body":"Heap Time Complexity Ops Time Peek O(1) Poll O(lgn) Offer O(lgn) Heapify O(n) Update O(n + lgn) "},"Heap/Impl/0 - Min Heap.html":{"url":"Heap/Impl/0 - Min Heap.html","title":"Min Heap","keywords":"","body":"Min Heap public class MinHeap { /** * actual data */ int[] arr; /** * how many numbers exists */ int size; public MinHeap(int[] arr) { if (arr == null || arr.length == 0) { throw new IllegalArgumentException(\"input array cannot be null or empty\"); } this.arr = arr; this.size = arr.length; heapify(); } public MinHeap(int cap) { if (cap = size) { throw new UnsupportedOperationException(\"Index is invalid\"); } int lastVal = arr[idx]; arr[idx] = val; if (val lastVal) { percolateDown(idx); } } private void percolateUp(int idx) { int parent = getParent(idx); while (parent >= 0 && arr[idx] = 0; i--) { percolateDown(i); } } private int getParent(int idx) { return (idx - 1) / 2; } private int leftChild(int idx) { return idx * 2 + 1; } private int rightChild(int idx) { return idx * 2 + 2; } private void swap(int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } "},"Heap/Impl/1 - Max Heap.html":{"url":"Heap/Impl/1 - Max Heap.html","title":"Max Heap","keywords":"","body":"Max Heap /** * @author Alex CHEN * @version 1.0 * @since 2020-07-26 21:07 */ public class MaxHeap { /** * actual data */ int[] arr; /** * how many numbers exists */ int size; public MaxHeap(int[] arr) { if (arr == null || arr.length == 0) { throw new IllegalArgumentException(\"input array cannot be null or empty\"); } this.arr = arr; this.size = arr.length; heapify(); } public MaxHeap(int cap) { if (cap = size) { throw new UnsupportedOperationException(\"Index is invalid\"); } int lastVal = arr[idx]; arr[idx] = val; if (val > lastVal) { percolateUp(idx); } else if (val = 0 && arr[idx] > arr[parent]) { swap(parent, idx); idx = parent; } } private void percolateDown(int idx) { while (leftChild(idx) arr[leftChild]) { candidate = rightChild; } if (arr[candidate] > arr[idx]) { swap(idx, candidate); idx = candidate; } else { break; } } } private void heapify() { for (int i = size / 2 - 1; i >= 0; i--) { percolateDown(i); } } private int getParent(int idx) { return (idx - 1) / 2; } private int leftChild(int idx) { return idx * 2 + 1; } private int rightChild(int idx) { return idx * 2 + 2; } private void swap(int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } "},"Heap/Impl/2 - Comparable.html":{"url":"Heap/Impl/2 - Comparable.html","title":"Heap With Comparable","keywords":"","body":"Heap With Comparable /** * @author Alex CHEN * @version 1.0 * @since 2020-07-26 21:07 */ public class ComparableHeap { /** * actual data */ String[] arr; /** * how many numbers exists */ int size; public ComparableHeap(String[] arr) { if (arr == null || arr.length == 0) { throw new IllegalArgumentException(\"input array cannot be null or empty\"); } this.arr = arr; this.size = arr.length; heapify(); } public ComparableHeap(int cap) { if (cap = size) { throw new UnsupportedOperationException(\"Index is invalid\"); } String lastVal = arr[idx]; arr[idx] = val; if (val.compareTo(lastVal) 0) { percolateDown(idx); } } private void percolateUp(int idx) { int parent = getParent(idx); while (parent >= 0 && arr[idx].compareTo(arr[parent]) = 0; i--) { percolateDown(i); } } private int getParent(int idx) { return (idx - 1) / 2; } private int leftChild(int idx) { return idx * 2 + 1; } private int rightChild(int idx) { return idx * 2 + 2; } private void swap(int i, int j) { String temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } "},"Heap/Impl/3 - Comparator.html":{"url":"Heap/Impl/3 - Comparator.html","title":"Heap With Comparator","keywords":"","body":"Heap With Comparator import java.util.Comparator; /** * @author Alex CHEN * @version 1.0 * @since 2020-07-26 21:53 */ public class ComparatorHeap { private Student[] students; private int size; private StudentComparator comparator; public ComparatorHeap(Student[] students, StudentComparator comparator) { this.students = students; this.size = students.length; this.comparator = comparator; heapify(); } public ComparatorHeap(int cap, StudentComparator comparator) { students = new Student[cap]; this.size = 0; this.comparator = comparator; } public int size() { return this.size; } public boolean isEmpty() { return size == 0; } public boolean isFull() { return size == students.length; } public Student peek() { return students[0]; } public Student poll() { Student ans = students[0]; students[0] = students[size - 1]; size--; percolateDown(0); return ans; } public void offer(Student s) { students[size++] = s; percolateUp(size - 1); } public void update(int idx, Student s) { Student prev = students[idx]; students[idx] = s; if (comparator.compare(prev, s) 0) { percolateUp(idx); } } private void percolateUp(int idx) { int parent = getParent(idx); while (parent >= 0 && comparator.compare(students[parent], students[idx]) > 0) { swap(parent, idx); idx = parent; parent = getParent(idx); } } private void percolateDown(int idx) { while (leftChild(idx) 0) { candidate = rightChild; } if (comparator.compare(students[candidate], students[idx]) = 0; i--) { percolateDown(i); } } private int getParent(int idx) { return (idx - 1) / 2; } private int leftChild(int parent) { return parent * 2 + 1; } private int rightChild(int parent) { return parent * 2 + 2; } private void swap(int i, int j) { Student temp = students[i]; students[i] = students[j]; students[j] = temp; } private static class Student { int id; int score; public Student(int id, int score) { this.id = id; this.score = score; } @Override public String toString() { return \"[\" + id + \",\" + score + \"]\"; } } private static class StudentComparator implements Comparator { @Override public int compare(Student s1, Student s2) { if (s1.score == s2.score) return 0; return s1.score "},"Heap/Impl/4 - Resizable.html":{"url":"Heap/Impl/4 - Resizable.html","title":"Resizable","keywords":"","body":"Resizable /** * @author Alex CHEN * @version 1.0 * @since 2020-07-26 21:07 */ public class ResizableMinHeap { /** * actual data */ int[] arr; /** * how many numbers exists */ int size; private static int defaultSize = 1; private static double factor = 1.5; public ResizableMinHeap(int[] arr) { if (arr == null || arr.length == 0) { throw new IllegalArgumentException(\"input array cannot be null or empty\"); } this.arr = arr; this.size = arr.length; heapify(); } public ResizableMinHeap() { arr = new int[defaultSize]; size = 0; } public int size() { return this.size; } public boolean isEmpty() { return size == 0; } public boolean isFull() { return size == arr.length; } public int peek() { return arr[0]; } public int poll() { if (isEmpty()) return -1; int ans = arr[0]; arr[0] = arr[size - 1]; size--; percolateDown(0); return ans; } public void offer(int val) { if (isFull()) { resize(); } arr[size++] = val; percolateUp(size - 1); } public void update(int idx, int val) { if (idx = size) { throw new UnsupportedOperationException(\"Index is invalid\"); } int lastVal = arr[idx]; arr[idx] = val; if (val lastVal) { percolateDown(idx); } } private void percolateUp(int idx) { int parent = getParent(idx); while (parent >= 0 && arr[idx] = 0; i--) { percolateDown(i); } } private void resize() { int newSize = (int) (factor * size) + 1; int[] newArray = new int[newSize]; System.arraycopy(arr, 0, newArray, 0, arr.length); arr = newArray; } private int getParent(int idx) { return (idx - 1) / 2; } private int leftChild(int idx) { return idx * 2 + 1; } private int rightChild(int idx) { return idx * 2 + 2; } private void swap(int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":""}}